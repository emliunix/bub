# 2026-02-18 - E2E Test Success & Deployment Script Enhancement

## Summary
Successfully completed end-to-end testing with the mock Telegram bridge. The agent now correctly responds with AI-generated messages instead of API errors. Also enhanced the deployment script to handle dynamically spawned agents.

## E2E Test Results

### Test Flow (PASSED ✅)
1. ✅ Bridge connects and subscribes to `tg:{chat_id}`
2. ✅ Spawn request sent to system agent
3. ✅ Agent spawned and returns `spawn_result`
4. ✅ Bridge waits for agent startup (3 second delay)
5. ✅ `tg_message` sent to agent
6. ✅ Agent processes message through MiniMax API
7. ✅ `tg_reply` sent to `tg:{chat_id}`
8. ✅ Bridge receives AI-generated response

### Sample Response
```
Hello! I'm ready to help you with whatever you need. I have access to a variety of tools for:
- **Fi...
```

### Key Fixes Applied

#### 1. Message Payload Field Names
**Issue:** Payloads used `from_` (Python reserved word workaround) but JSON-RPC expected `from`.

**Fix:** Changed `create_tg_message_payload()` and `create_tg_reply_payload()` to use `"from"` instead of `"from_"`.

**File:** `src/bub/message/messages.py`

#### 2. Agent Reply Addressing
**Issue:** Agent was sending replies to `telegram:{chat_id}` but bridge subscribed to `tg:{chat_id}`.

**Fix:** Added channel prefix mapping in agent:
```python
channel_prefix = "tg" if message.channel == "telegram" else message.channel
await client.send_message(to=f"{channel_prefix}:{message.chat_id}", ...)
```

**File:** `src/bub/cli/app.py:293-294`

#### 3. Test Script API Updates
**Issue:** Test scripts used outdated `client._api.send_message(SendMessageParams(...))` API.

**Fix:** Updated to use simplified `client.send_message(to, payload)` API.

**Files:** `scripts/test_e2e_clean.py`, `scripts/test_e2e_automated.py`

#### 4. System Agent Configuration Passing
**Issue:** API key and API base were not being passed to spawned agents.

**Fix:** System agent now uses `AgentSettings` to read config and passes:
- `BUB_AGENT_API_KEY`
- `BUB_AGENT_API_BASE` (critical for MiniMax)
- `BUB_AGENT_MODEL`
- `BUB_AGENT_MAX_TOKENS`
- `BUB_AGENT_MAX_STEPS`

**Files:** `src/bub/system_agent.py`

## Deployment Script Enhancement

### Problem
`./deploy-production.sh stop all` only stopped static components (bus, system-agent, tape, etc.) but left dynamically spawned agents running.

### Solution
Added `stop_dynamic_agents()` function that:
1. Reads `sessions.json` to find all spawned agent units
2. Extracts `systemd_unit` names from each session
3. Stops each running agent via `systemctl --user stop`
4. Reports count of stopped agents

**File:** `scripts/deploy-production.sh:206-252`

### Usage
```bash
./deploy-production.sh stop all
# Output now includes:
#   Stopping dynamically spawned agents...
#      Stopping bub-agent-worker-xxx...
#   ✅ Stopped N dynamic agent(s)
```

## Commits Made

1. `5010033` - feat(deployment): stop dynamic agents from sessions.json on stop all

## Configuration Notes

For MiniMax to work correctly, ensure `.env` contains:
```bash
BUB_AGENT_MODEL=minimax:MiniMax-M2.5
BUB_AGENT_API_BASE=https://api.minimaxi.com/v1
BUB_AGENT_API_KEY=sk-...
```

## Status
- ✅ E2E test passing
- ✅ Dynamic agent cleanup working
- ✅ Full protocol flow verified
- ✅ Deployment script enhanced

## Framework: Concurrent Request Handling Fix

### Problem
The JSON-RPC framework had a deadlock issue: when a request handler tried to send a request and wait for a response, the framework's message loop was blocked waiting for the handler to complete. This prevented the framework from processing the response.

### Root Cause
In `src/bub/rpc/framework.py`, `_handle_request()` was awaiting the handler directly:
```python
result = await handler(params)  # Blocks message loop
```

When handler code does:
```python
async def handler(params):
    result = await send_request_and_wait()  # Deadlock! Loop can't process response
```

### Solution
Run request handlers as background tasks so the message loop can continue processing messages:
```python
async def _handle_request(self, request):
    task = asyncio.create_task(self._run_request_handler(request, handler))
    _background_tasks.add(task)
    task.add_done_callback(_cleanup_background_task)
```

### Files Changed
| File | Lines Changed | Description |
|------|---------------|-------------|
| `src/bub/rpc/framework.py` | +35/-17 | Run handlers as background tasks |

### Key Changes
1. Added global `_background_tasks: set[asyncio.Task[Any]]` to prevent GC
2. Added `_cleanup_background_task()` to remove completed tasks
3. Split `_handle_request()` into dispatch (creates task) and `_run_request_handler()` (executes handler)

### Tests
✅ `test_bus_integration_3clients.py` - Basic 3-client test
✅ `test_bus_concurrent.py` - Handler responds from within message handler

### Status
✅ Concurrent request handling implemented
✅ Deadlock issue resolved
✅ All tests passing
